{
    "collab_server" : "",
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n#\nsource(\"/home/ruser/TextPrism/RSource/ML_functions.R\")\nrequire(shiny)\nrequire(dplyr)\nrequire(stringi)\nrequire(tm)\nrequire(reshape)\nrequire(slam)\nrequire(SnowballC)\nrequire(RODBC)\nrequire(RODBCext)\nrequire(igraph)\nrequire(network)\nrequire(sna)\nrequire(ggplot2)\nrequire(GGally)\n\nmakeCorpus <- function(inputQuery, stopTerm){\n  \n  start.time <- Sys.time()\n  \n  ############################################\n  ## Read in TM results\n  ############################################\n  #DB Connection\n  print(\"Connect DB\")\n  #conn <- odbcConnect('smartSMA_Development_New',uid='trendtracker',pwd='#tt1234')\n  conn <- odbcConnect('ccaMart',uid='trendtracker',pwd='#tt1234')\n  #conn <- odbcConnect('smaali',uid='namyun',pwd='dighdi12')\n  #conn <- odbcConnect('Alibaba',uid='trendtracker',pwd='#tt1234')\n  print(\"Loading Data from DB\")\n  inputQuery = 'Select crawl_data_id, role, keyword, ranking from ccadb.t_tp_result_rank_lgu where user = \\'comm_con_dev\\';'\n  tm<-sqlQuery(conn,inputQuery)\n  odbcClose(conn)\n  \n  #Pre Processing\n  tm$keyword <- gsub(\" \", \"#\", tm$keyword)\n  #tm$keyword <- replace(tm$keyword, (tm$keyword %in% \"알파\"), \"알파고\")\n  #tm$keyword <- replace(tm$keyword, (tm$keyword %in% \"알파고가\"), \"알파고\")\n  #tm$keyword <- replace(tm$keyword, (tm$keyword %in% \"알파고와\"), \"알파고\")\n  #tm$keyword <- replace(tm$keyword, (tm$keyword %in% \"이세돌과\"), \"이세돌\")\n  \n  \n  ## Stop Term ##\n  disuse.term <- stri_split_fixed(stopTerm, \",\")\n  #disuse.term <- c(\"아다\", \"와의\", \"수로\",\"서울\",\"오후\",\"어제\",\"판후\",\"디어\",\"쓰다\",\"금지\",\"배포\")\n  disuse.role <- c(\"OL\")\n  tm <- tm[!(tm$role %in% disuse.role),]\n  tm <- tm[!(tm$keyword %in% disuse.term[[1]]),]\n  \n  tmKeyword <- fn_tm_keys(tm)\n  print(paste(\"Total Document :\",nrow(tmKeyword)))\n\n  \n  ##Duplication Check\n  dupCheck <- duplicated(tmKeyword[,2])\n  tmKeyword <- tmKeyword[!dupCheck,]\n  \n  print(paste(\"Target Document :\",nrow(tmKeyword)))\n  \n  end.time <- Sys.time()\n  runtime <- end.time - start.time\n  print(\"DB Loading Time: \")\n  print(runtime)\n  return(tmKeyword)\n}\n\nmakeDtm <- function(tmKeyword, sparse){\n  corp<-Corpus(DataframeSource(tmKeyword))\n  dtm<-DocumentTermMatrix(corp, control=list(removeNumbers=TRUE, wordLengths=c(2,Inf)))\n  dtm <- removeSparseTerms(dtm, as.numeric(sparse))\n  \n  return(dtm)\n}\n\n\nmakeAssMat <- function(dtm, mainTerm, corlimit){\n  ## Create asscoiation keyword ##\n  mTerm <- stri_split_fixed(mainTerm, \",\")\n  mTerm <- mTerm[[1]]\n  assDf <- NULL\n  \n  for(i in 1:length(mTerm)){\n    print(mTerm[i])\n    at <-findAssocs(dtm, mTerm[i], corlimit)\n    tempTerm <- mTerm[i]\n    \n    atDf <- data.frame(at[1])\n    weight <- atDf[1]\n    term <- rownames(atDf)\n    temp <- cbind(weight,term)\n    \n    if(is.null(assDf)){\n      assDf <- temp\n    }\n    else{\n      assDf <- merge(assDf, temp, by.x=\"term\", by.y=\"term\", all.x = TRUE, all.y = TRUE)\n      assDf <- replace(assDf, is.na(assDf), 0)\n      rm(temp)\n    }\n  }\n    \n    ## Convert a Data Frame to a Numeric Matrix  ##\n    new_dtmMatrix <- as.matrix(assDf[,2:ncol(assDf)])\n    rownames(new_dtmMatrix)<- as.character(assDf[,1])\n    new_dtmMatrix[new_dtmMatrix>=0.02] <- 1\n    new_dtmMatrix[new_dtmMatrix<0.02] <- 0\n    \n    return(new_dtmMatrix)\n}\n\nmakeNetwork <- function(new_dtmMatrix){\n  \n}\n\n\n\nshinyServer(function(input, output) {\n  \n  getNetwork <- reactive({\n    if(input$inputSql != 'Insert SQL!!'){\n      withProgress({\n        setProgress(message = \"Loading corpus...\")\n        corpusResult <- makeCorpus(input$inputSql, input$stopTerm)\n        \n        setProgress(message = \"Create DTM...\")\n        dtm <- makeDtm(corpusResult, input$sparse)\n        \n        setProgress(message = \"Create Network Matrix...\")\n        new_dtmMatrix <- makeAssMat(dtm, input$mainTerm, input$corlimit)\n        \n        setProgress(message = \"Create Network Graph...\")\n        net <- network(new_dtmMatrix, directed=FALSE)\n        net %v% \"mode\" <- ifelse(betweenness(net)>mean(betweenness(net)), \"big\", \"small\")\n        col = c(\"small\" = \"grey\", \"big\" = \"gold\")\n        network <- ggnet2(net,mode = \"kamadakawai\", label=TRUE, color = \"mode\", palette = col)\n        #network <- ggnet2(net,mode = \"kamadakawai\", label=TRUE)\n      })\n    }else{\n      network <- NULL\n    }\n    return(network)\n  })\n  \n  output$network <- renderPlot({\n    getNetwork()\n  })\n\n})\n",
    "created" : 1482812406673.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "707925568",
    "id" : "5B8EA9BF",
    "lastKnownWriteTime" : 1464875378,
    "last_content_update" : 1464875378,
    "path" : "~/GitHub/TextMining/Keyword_UI/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}